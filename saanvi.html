<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="logo">City Design</div>
        <ul class="nav-links">
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="project.html">Project</a></li>
            <li><a href="amogh.html">Amogh</a></li>
            <li><a href="bhoomika.html">Bhoomika</a></li>
            <li><a href="saanvi.html">Saanvi</a></li>
            <li><a href="Ramya.html">Ramya</a></li>
        </ul>
    </nav>

    <!-- Business Ideas Section -->
    <section class="business-ideas">
        <h2 class="head">Identified Business Ideas</h2>
        <div class="ideas-box">
            <div class="idea">
                <h3>Tourism</h3>
                <p>
                    Sustainable tourism is directly related to SDG 11.4.1 which focuses on preservation, protection and conservation of all cultural and natural heritage
                    <br> We can establish a buisness based on:
                    <ul>
                        <li>Revenue generated can be reinvested in conservation projects.</li>
                        <li>It provides economic benefits to local communities.</li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Recycling Unit</h3>
                <p>
                    SDG 11.6.1  states that proportion of municipal solid waste collected and managed in controlled facilities out of total municipal waste generated, by cities.
                    <br> Recycling supports this goal by:
                    <ul>
                        <li>Recycling unit reduces the environmental impact by reducing the waste.</li>
                        <li>Recycling reduces the need of raw material extraction</li>
                        <li>It reduces pollution and greenhouse gases caused due to the improper disposal of waste directly to the environment</li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Wheat processing unit</h3>
                <p>
                    SDG 2(zero hunger) and SDG 9(industry, innovation and infrastructure) are primarily targerted by this buisness idea but it indirectly leads to SDG 11.3.2 which states that Proportion of cities with a direct participation structure of civil society
                <br>
                Wheat processing unit will contribute towards this by:
                <li>Enhancing local food production and distribution</li>
                <li>Encouraging community involvement and providing local employment opportunities</li>
            </p>
            </div>

            <div class="idea">
                <h3>Production of Mulberry Silk</h3>
                <p>
                    SDG 8(Decent work and economic growth) and SDG 9(industry, innovation and infrastructure) are directly affected by this buisness idea and indirectly leads to the sdg 11.4.1 which focuses on preservation, protection and conservation of all cultural and natural heritage
                    <br>Production of mulberry silk contributes to this by:
                    <ul>
                        <li>The cultivation of mulberry trees and the rearing of silkworms are environmentally friendly practices that promote biodiversity and sustainable land use</li>
                        <li>Sericulture (silk farming) provides employment and income for rural communities, supporting sustainable economic growth</li>
                        <li>Mulberry silk production contributes to the preservation of cultural heritage and traditional practices.</li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Heathcare and fitness centres</h3>
                <p>
                    It primarily focuses on SDG 3(Good health and well being) but indirectly also leads to SDG 11.7.1 which that average share of the built-up area of cities that is open space for public use for all, by sex, age and persons with disabilities.
                    <br>Health and fitness centres contribute to this by:
                    <li>Establishing well-designed and safe healthcare and fitness environments contributes to the overall well-being of urban populations.</li>
                    <li>By offering accessible healthcare and fitness facilities, these centers ensure that all community members, including marginalized groups, have access to health services and physical activities.</li>  
                </p>
            </div>
        </div>
    </section>

    <!-- Reflection Section -->
    <section class="Reflection">
        <h2>Course Reflections</h2>
        <div class="reflection-box">
            <ol>
                <li>
                    What are the kinds of problems we see in nature? (iteration, recursion, backtracking)
                    <p class="ans">Nature poses a lot of complex problems. The life cycle, the food chain are some problems which can be solved using recursion. Predicting the climate change is a problem which can be solved using iteration. Bees use backtracking to find optimal path for foraging. When plants grow they mend themselves such that they get maximum sun exposure, this is another example of backtracking.</p>
                </li>
                <li>
                    What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.
                    <p class="ans">Time efficiency is how fast an algorithm runs. Space efficiency is the extra space the algorithm runs.
                        Time efficiency is important as in real world we prefer the algorithms which are quick and efficient.
                        Space efficiency ensures optimal use of the resource (maximum utilization of minimal resources)                        
                        <br> O(1): constant order of growth 
                        <br> O(n): linear order of growth 
                        <br> O(log n): logarithmic order of growth 
                        <br> O(nlogn): Runtime increases more than linear but less than quadratic with input size.
                        <br> O(n2): Runtime increases quadratically.
                        <br> O(n3): Runtime increases cubic.
                        <br> O(2^n): The runtime grows exponentially.
                        <br> O(n!): The runtime grows extremely fast.
                    </p>
                </li>
                <li>
                    Take away from different design principles from chapter 2?
                <p class="ans">The key takeaway from the design principles was how simple design principles simplified complex problems making the algorithms more efficient and effective. We broke down problems using principles like decomposition, pattern recognition and abstraction to make the task more manageable. Pruning(used in N-queens) and lazy propagation(used in segment trees) optimizes resource usage. From pruning we learn to eliminate the possible solutions which do not lead to the desired result. Lazy propagation is kind of like smart procrastination where it differs update until needed. Hierarchical order(BST) and level order traversal(BFS) help us to process data. From the principle of pre-computing used in lookup table we learn we can simplify the problem by storing the results of frequent operations. In heap we use the concept of parental dominance to increase the efficiency and maintain the hierarchical order. We learn how to speed up computations by bit manipulation used in Fenwick tree. The principle of brave and cautious traversal is used in DFS, BFS which help us to navigate the graph effectively.
                    In all, these principles create efficient algorithms.
                </p>  
                </li>
                <li>
                    The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
                    <p class="ans">Binary search tree efficiently performs functions like searching and insertion. 2-3 trees maintain the depth of the tree. AVL trees are self balancing. Red-black trees balance themselves using colors. Heaps maintain the parental dominance and ease deletion. Tries search efficiently using prefix based searches. </p>
                </li>
                <li>
                    The need for array query algorithms and their implications. Their applications and principles need to be discussed.
                    <p class="ans">Array query algorithms are crucial for searching, updating and querying elements of an array. They are essentially used when handling huge datasets. Array queries are essential for accessing data within specific intervals. 
                        <br>Lookup Tables:A lookup table for range queries is a data structure used to efficiently answer queries about a specific range of values in a dataset. It pre-computes information, such as minimum, maximum, or sum, for various intervals of data. Pre-computing is the concept used in it as it saves the results. 
                        <br>Segment trees:Segment trees divides the array creating a binary tree. it has bottom up approach. It uses the principle of Lazy propagation. All the changes are stored and only updated when necessary. 
                        <br>Sparse table:Sparse table is used for fast queries on a set of static data. It does preprocessing so that the queries can be answered efficiently. 
                        <br>Fenwick Trees:Fenwick trees are used to find the sum, minimums/ maximums. Each node holds data for a range of specific elements making it quick. The principle used is bit manipulation.
                        </p>
                </li>
                <li>
                    Differentiate between tree and graphs and their traversals. The applications of each.
                    <p class="ans">Trees
                        <br>1. Trees have a hierarchical order with a single parent per node. Ensuring easy access for searching and organization. The give us a structured path.
                        <br>2. Traversals are preorder, in order, post order.
                        <br>3. Applications: they find applications to ease searching and insertion.
                        
                        <br>Graphs
                        <br>1. Graphs have nodes and edges which can be either undirected or bidirected, weighted or unweighted. The display relationships between nodes. They provide us with efficient paths.
                        <br>2. There are 2 methods of traversal for an unweighted graph: BFS and DFS.
                        <br>3. Applications: Network routing.
                        </p>
                </li>
                <li>
                    Deliberate on sorting and searching algorithms, the technique behind each and how they connect to the real world.
                    <p class="ans">Techniques include bubble sort, merge sort, quick sort, insertion sort, selection sort.
                        <br>In bubble sort we compare the elements to the entire length and swap where needed. Selection sort is an improvement over this, which only swaps the minimum element. Inspired from the gamblers problem, Insertion sort is an improvement over this, which adds elements and shifts them accordingly.
                        <br>Merge sort, quick sort and heap work on the principle of divide and conquer. Merge sort works similar to binary search by dividing it into halves. These algorithms divide, sort, and then join the results are repeat the process.
                        <br>The real life applications of these are in websites to filter on basis of preferences and to sort huge datasets, the for transaction ordering or ranking in websites.
                        <br>For searching we use linear search which searches linearly. In binary search we divide the data in halves. Applications include using search tools or retrieving some information from datasets.</p>
                </li>
                <li>
                    Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.
                    <p class="ans">Graph algorithms are essential for solving such problems. If we need to find the maximum/minimum cost required for traversal we use the algorithms Kruskal and Prim's. This minimizes the cost of traversal. Applications include minimizing the cost of laying cables, pipelines and developing network. When we need to find the shortest path to navigate we use algorithms like- Dijkstra, Floyd Warshall. They are essential for network routing, mapping etc. Thus spanning trees and shortest paths enhance the efficiency and reduce cost.</p>
                </li>
                <li>
                    Discuss the different studied algorithm design techniques.
                    <p class="ans">The first design technique we learned about in the class was backtracking. To understand we solved problems such as n-queens problem, subset generation. We solve every possible was and prune/eliminate the answer which is not needed. In the same unit we learned the concept of transform and conquer by understanding AVL trees, heap and 2-3 trees.
<br>The next design technique encountered was decrease and conquer in the way of traversing the graph. There are two ways to traverse the graph- Breadth First search (BFS) and Depth First Search (DFS). In BFS we visited the nodes directly connected to the source node first and sequentially visited all nodes. In DFS we first go along a single path and then when we return back to the source, only then do we explore other paths. We saw various sorting techniques which used the principle of divide and conquer. By dividing it into smaller parts and then integrating it. In string matching we came across design principles such as brute-force; hashing and algorithms like Boyer Moore which use the principle of space and time tradeoff . We then saw problems the greedy problem in which we find the shortest path between nodes in a weighted graph by Prim’s, Kruskal’s, Dijkstra’s Algorithm.
                        </p>
                </li>
            </ol>
        </div>
    </section>
    <section class="case-breakdown">
        <h2 class="breakdown-head">Breakdown Of Business Ideas</h2>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Wheat Processing and Manufacturing</h2>
                <p class="explain">
                    <ul>
                        <li>
                            A city needs a wheat processing and manufacturing industry to ensure a steady food supply, 
                            support local farmers, and boost the economy. Processing wheat locally reduces transportation costs, 
                            adds value to raw materials, and creates jobs across agriculture, manufacturing, and logistics. 
                            It enhances food security, makes products affordable, and fosters urban-rural linkages. It strengthens
                            the city’s role in domestic and global trade, driving economic growth while reducing dependence
                            on external suppliers and enhancing overall self-sufficiency.
                        </li>
                        <li>
                            To understand the supply of wheat and the demand for wheat products, we can start with data collection
                            and analysis. Use arrays to store data on wheat production from different farms and regions. 
                        </li>
                        <li>
                            While monitoring and maintaining these wheat fields we need level-by-level exploration. This can be achieved by Breadth-First Search (BFS) to ensure systematic coverage of all fields.
                        </li>
                        <li>
                            Once we have the data on wheat supply, we need to sort the wheat batches based on quality attributes such 
                            as protein content, moisture level, and kernel size. Sorting algorithms like <b>quick sort</b> can be employed 
                            to order the wheat batches.
                        </li>
                        <li>
                            Transportation is a critical aspect of wheat processing. We need to ensure that wheat is 
                            efficiently transported from farms to processing facilities and from facilities to markets. 
                            Graph algorithms like <b>Floyd's algorithm</b> can be used to to analyze all possible routes between multiple 
                            processing facilities and distribution points to find the most efficient path. This reduce delivery time.
                        </li>
                        <li>
                            For efficient inventory management, implement a <b>heap data structure</b> to maintain the highest
                            or lowest quality wheat batches for quick access. This ensures that high-quality batches are 
                            prioritized for processing and that inventory levels are kept under control.

                        </li>
                        <li>
                            During the processing stage, we can use <b>queues</b> to manage the order of wheat batches to be
                            processed. The FIFO nature of queues ensures that batches are processed in the order they arrive,
                            maintaining a smooth workflow.
                        </li>
                        <li>We also need to continuously monitor and improve the wheat processing and manufacturing process.
                            For example, use <b>segment trees</b> to handle range queries on production data, allowing for
                            real-time analysis of production levels.
                        </li>
                        <img src="WPP.png" alt="Wheat Production and Processing Phases">
                    </ul>
                <ul>
    <li><b>Sample Code for Array</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Access: O(1)</li>
        <li>Insertion: O(n)</li>
        <li>Deletion: O(n)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/array_with_structures.cpp" class="code">Sample Code for Array</a> <br><br>

    <li><b>Breadth First Search</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges.</li>
        <li>Space Complexity: O(V)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/bfs.cpp" class="code">Sample Code for BFS</a> <br><br>

    <li><b>Sorting Algorithms: Quick Sort, Merge Sort, Heap Sort</b></li>
    <p><b>Quick Sort Efficiency:</b></p>
    <ul>
        <li>Average Time Complexity: O(n log n)</li>
        <li>Worst Time Complexity: O(n^2)</li>
        <li>Best Time compexity: O(1.38 n log n)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/QUCIKSORT.cpp" class="code">Sample Code for Quick Sort</a> <br><br>
    <li><b>Floyd's Algorithm</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Time Complexity: O(V^3), where V is the number of vertices.</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/floyd.cpp" class="code">Sample Code for Floyd's</a> <br><br>

    <li><b>Heap</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion: O(log n)</li>
        <li>Deletion: O(log n)</li>
        <li>Access: O(1)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/heap.cpp" class="code">Sample Code for Heap</a> <br><br>

    <li><b>Queue Data Structure</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion (Enqueue): O(1)</li>
        <li>Deletion (Dequeue): O(1)</li>
        <li>Access: O(n)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/queue.cpp" class="code">Sample Code for Queue</a> <br><br>

    <li><b>Segment Trees</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion/Query: O(log n)</li>
        <li>Update: O(log n)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/segment.cpp" class="code">Sample Code for Segment Tree</a> <br><br>
                </ul>   </p>
            </div>
        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Tourism</h2>
                <p class="explain">
                    <ul>
                        <li>
                            The tourism industry is crucial for a city as it drives economic growth by generating revenue 
                            and creating jobs in sectors like hospitality, transport, and retail. It promotes cultural 
                            preservation by showcasing local heritage and traditions, while fostering intercultural exchange.
                            Tourism also encourages infrastructure development, improving facilities like roads, public
                            transportation, and public spaces, benefiting both residents and visitors. It supports 
                            environmental conservation and eco-tourism initiatives.
                        </li>
                        <li>
                        We first took a sample area. To represent the connections between different tourist attractions, hotels, 
                        and services. Each node can represent a location, and edges can represent routes or relationships between them. 
                        After mapping the nodes we can decide the route by <b>Prim's algorithm</b> to minimize the cost of traversal and 
                        maximize visitor experience.
                        </li>
                        <li>
                           To enhance the tourist experience, we can develop personalized recommendation systems. 
                            We can implement auto-complete features for tourist destinations, helping tourists quickly 
                            find relevant information using <b>trie</b>
                        </li>
                        <li>
                            To manage booking and reservation processes on a first-come, first-served basis we can
                            implement <b>queue</b>
                        </li>
                        <li>
                            To securely store sensitive data of visitors, such as payment information and personal details.
                            <b>Hashing</b> ensures that sensitive information is stored securely and can be retrieved
                            efficiently when needed.
                        </li>
                    </ul>
                <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
    
    
    <li><b>Prim's Algorithm</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Time Complexity: O(E log V), where E is the number of edges and V is the number of vertices.</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/prim.cpp" class="code">Sample Code for Prim's</a> <br><br>

    <li><b>Trie</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion: O(L), where L is the length of the word.</li>
        <li>Search: O(L), where L is the length of the word.</li>
        <li>Deletion: O(L), where L is the length of the word.</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/trie.cpp" class="code">Sample Code for Trie</a> <br><br>

    <li><b>Queue</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion (Enqueue): O(1)</li>
        <li>Deletion (Dequeue): O(1)</li>
        <li>Access: O(n)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/queue.cpp" class="code">Sample Code for Queue</a> <br><br>

    <li><b>Hashing Algorithms</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion: O(1) on average</li>
        <li>Search: O(1) on average</li>
        <li>Deletion: O(1) on average</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/hashing.cpp" class="code">Sample Code for Hashing</a> <br><br>

                    </ul>
                </p>
            </div>
        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Healthcare and Wellness Centres</h2>
                <p class="explain">
                    <ul>
                        <li>
                            Healthcare and wellness centers address urban health needs by offering accessible, affordable care,
                            preventive services, and stress management programs. They decongest hospitals, support vulnerable groups,
                            and ensure quick emergency responses. Promoting health education and community well-being, these centers
                            foster a healthier workforce and contribute to economic growth and resilient urban living.
                        </li>
                        <li>
                            We prioritize patients based on urgency or severity of their medical conditions. 
                            By using a priority queue, we can ensure that patients in critical need are treated first,
                            based on their priority level.
                        </li>
                        <li>
                            We can optimize ambulance routing by finding the shortest paths between emergency locations 
                            and hospitals by using graph algorithm like <b>dijkstra</b>
                        </li>
                        <li>
                            To efficiently search for patients name in the records we can use <b>trie</b>. Trie enables fast retrieval of patient 
                            data using prefixes, such as patient names or conditions.
                    </li>
                        <li>
                            <b>Hashing</b> enables efficient management of patient records by mapping unique identifiers
                            (e.g., Patient ID) to detailed information for quick access, insertion, and deletion. 
                            It ensures fast retrieval, even with large datasets, using hash tables. Secure methods 
                            like cryptographic hashes enhance data privacy, crucial for sensitive healthcare applications.
                        </li>
                        <li>
                            A <b>Binary Search Tree (BST)</b> can be used for bed allocation by organizing beds based on 
                            attributes like bed type, floor, or priority. Each node represents a bed, and its left or
                            right child represents a higher or lower priority. This allows quick search, allocation,
                            and updates of available beds.
                        </li>
                        <li>
                            <b>Rabin-Karp</b> helps hospitals detect genetic disorders, pathogens, and mutations. Its hash-based matching 
                            efficiently analyzes DNA/protein sequences, aiding personalized medicine, biomarker identification, drug discovery, 
                            and wellness genomics programs.
                        </li>
                    </ul>
                <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
    <li><b>Priority Queue</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion: O(log n)</li>
        <li>Deletion: O(log n)</li>
        <li>Access: O(1)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/priority_queue.cpp" class="code">Sample Code for Priority Queue</a><br> <br>

    <li><b>Dijkstra</b></;i>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Time Complexity: O(V^2) with a simple implementation or O(E + V log V) with a priority queue, where V is the number of vertices and E is the number of edges.</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/dijkstra.cpp" class="code">Sample Code for Dijkstra</a> <br><br>

    <li><b>Trie</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion: O(L), where L is the length of the word.</li>
        <li>Search: O(L), where L is the length of the word.</li>
        <li>Deletion: O(L), where L is the length of the word.</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/trie.cpp" class="code">Sample Code for Trie</a> <br><br>

    <li><b>Hashing</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion: O(1) on average</li>
        <li>Search: O(1) on average</li>
        <li>Deletion: O(1) on average</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/hashing.cpp" class="code">Sample Code for Hashing</a> <br><br>

    <li><b>Binary Search Tree</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion: O(log n) on average</li>
        <li>Search: O(log n) on average</li>
        <li>Deletion: O(log n) on average</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/bst.cpp" class="code">Sample Code for Binary Search Tree</a> <br><br>

    <li><b>Rabin-Karp</b></li>
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Average Time Complexity: O(n + m), where n is the length of the text and m is the length of the pattern.</li>
        <li>Worst Time Complexity: O(nm) in case of hash collisions.</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/rabinkarp.cpp" class="code">Sample Code for Rabin-Karp</a> <br><br>

                    </ul>
                </p>
            </div>
        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Recycling</h2>
                <p class="explain">
                    <ul>
                        <li>
                            A recycling unit in a smart city minimizes waste, conserves resources, reduces pollution, supports sustainability, promotes circular economy, 
                            and enhances urban livability by efficiently managing and reusing materials.
                        </li>
                        <li>
                            We can use <b>union-find</b> for managing connected components within the recycling network. This helps in grouping 
                            collection zones or processing units that can operate more efficiently together.
                        </li>
                        <li>
                            After identifying the locations, it is essential to plan the collection and transportation routes for the waste.
                            <b>Kruskal</b> algorithm is effective in calculating the shortest and most efficient
                            routes for waste collection vehicles. These algorithms minimize travel time and cost, ensuring that the transportation
                            process is efficient and cost-effective.
                        </li>
                        <li>
                            sorting the waste by type and volume becomes the next step. Sorting algorithms like <b>quick sort, merge
                            sort, or heap sort</b> are useful in efficiently organizing the waste, prioritizing the types with the
                            highest volume, and allocating resources for efficient processing. This ensures that the most urgent
                            or high-volume materials are processed first.
                        </li>
                        <li>
                           A <b>queue</b> data structure helps manage incoming recycling tasks in a first-come, first-served order or by priority, 
                            ensuring that tasks are handled systematically.
                        </li>
                        <li>
                           A <b>Fenwick Tree</b> can be used to efficiently monitor changes in inventory levels of recycled materials. For instance, 
                            when new materials are added to the inventory, or when materials are processed and removed, the Fenwick Tree can 
                            quickly update the cumulative totals. 
                        </li>
                    </ul>
                <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
    <li><b>Union-Find</b></li>   
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/union_find.cpp" class="code">Sample Code for Union-Find</a> <br>
    <br>
    <li><b>Kruskal</b></li>    
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Time Complexity: O(E log V), where E is the number of edges and V is the number of vertices</li>
    </ul>
      <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/kruskal's.cpp" class="code">Sample Code for Kruskal</a> <br>

    <br>

    <li><b>Sorting Algorithms</b></li>    
    <p><b>Efficiency (Quick Sort):</b></p>
    <ul>
        <li>Average Time Complexity: O(n log n)</li>
        <li>Worst Time Complexity: O(n^2)</li>
        <li>Best Case: O(n log n)</li>
    </ul>
     <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/QUCIKSORT.cpp" class="code">Sample Code for QuickSort</a> <br>

    <br>

    <li><b>Queue</b></li>    
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Insertion (Enqueue): O(1)</li>
        <li>Deletion (Dequeue): O(1)</li>
        <li>Access: O(n)</li>
    </ul>
    <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/queue.cpp" class="code">Sample Code for Queue</a> <br>

    <br>

    <li><b>Fenwick Tree</b></li>    
    <p><b>Efficiency:</b></p>
    <ul>
        <li>Update: O(log n)</li>
        <li>Query: O(log n)</li>
    </ul>
   <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/fenwick.cpp" class="code">Sample Code for Fenwick Tree</a> <br>

    <br>
                    </ul>
                </p>
            </div>
        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Mulberry Silk Production</h2>
                <p class="explain">
                    <ul>
                        <li>
                            Mulberry silk production in a smart city fosters sustainability, local employment, urban farming, cultural preservation, eco-friendly practices, and technological advancements, enhancing 
                            economic growth and aligning with sustainable urban development goals.
                        </li>
                        <li>
                            In the mulberry silk production business, different stages can be efficiently managed using specific data structures to optimize 
                            operations, track data, and support decision-making. In the initial stage of mulberry cultivation and maintenance a <b>Priority Queue</b> can schedule
                            tasks like watering or pruning based on urgency.
                        </li>
                        <li>
                            To manage the feeding schedule of silkworms in a first-come, first-served manner, ensuring that all larvae receive timely and adequate nutrition. A <b>queue</b> will fulfill this purpose                          
                        </li>
                        <li>
                            To manage the order of cocoons going into boiling, following a Last-In-First-Out (LIFO) approach to ensure optimal boiling cycles and temperature control <b>stack</b> can be implemented
                        </li>
                        <li>
                            In the silk yarn production stage, a <b>Linked List</b> handles continuous production batches and maintains a timeline.
                        </li>
                        <li>
                            For the efficient distribution of mulberry silk from the factory to various retailers or customers, 
                            the <b>Dijkstra's Algorithm</b> is highly effective.
                        </li>
                    </ul>
                <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Priority Queue</b></li>
                        <p><b>Efficiency</b></p>
                        <ul>
                            <li>Insertion: O(log n)</li> 
                            <li>Deletion: O(log n)</li> 
                            <li>Access: O(1)</li>
                        </ul>
                        <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/priority_queue.cpp" class="code">Sample Code for Kruskal's</a> <br><br>

                        <li><b>Queue</b></li>
                        <p><b>Efficiency</b></p>
                        <ul>
                            <li>Insertion (Enqueue): O(1)</li> 
                            <li>Deletion (Dequeue): O(1)</li>
                            <li>Access: O(n)</li>
                        </ul>
                        <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/queue.cpp" class="code">Sample Code for Queue</a> <br><br>

                        <li><b>Stack</b></li>
                        <p><b>Efficiency</b></p>
                        <ul> 
                            <li>Insertion (Push): O(1)</li> 
                            <li>Deletion (Pop): O(1)</li> 
                            <li>Access: O(n)</li> 
                        </ul>
                       <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/stack.cpp" class="code">Sample Code for Stack</a> <br><br>

                        <li><b>Linked List</b></li>
                        <p><b>Efficiency</b></p>
                        <ul> 
                            <li>Insertion: O(1)</li> 
                            <li>Deletion: O(1)</li> 
                            <li>Access: O(n)</li> </ul>
                         <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/singly_linked_list.cpp" class="code">Sample Code for Linked List</a> <br><br>

                        <li><b>Dijkstra</b></li>
                        <p><b>Efficiency</b></p>
                        <ul> 
                            <li>Time Complexity: O(V^2) with a simple implementation or O(E + V log V) with a priority queue, where V is the number of vertices and E is the number of edges.</li> 
                        </ul>
                     <br><a href="https://github.com/Saanvi0804/DSA_course_project/blob/main/dijkstra.cpp" class="code">Sample Code for Dijkstra</a> <br><br>

                    </ul>
                </p>
            </div>
        </div>
        <br>
        
        
</body>
</html>
